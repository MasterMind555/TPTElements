<i>// src/simulation/elements/&lt;elementname&gt;.cpp:</i>
#include "simulation/Elements.h"

//#TPT-Directive ElementClass Element_<b>BCOL</b> PT_<b>BCOL</b> <b>73</b>
Element_<b>BCOL</b>::Element_<b>BCOL</b>()
{
  <i>// Element's name on the new lua API - format it like NAMESPACE_PT_ELEMENTNAME</i>
  Identifier = "<b>DEFAULT_PT_BCOL</b>"; 
  <i>// Element's in-game name. (Limited to 4 letters!)</i>
  Name = "<b id="elname">BCOL</b>"; 
  <i>// Element's colour in hexadecimal in the format 0xRRGGBB</i>
  Colour = PIXPACK(0x<b>333333</b>); 
  <i>// Whether or not it's going to exist in any element menu.</i>
  MenuVisible = <b>1</b>; 
  <i>// Which menu section it's in.
  //Look for SC_* values in src/simulation/SimulationData.h</i>
  MenuSection = SC_<b>POWDERS</b>; 
  <i>// If the element is actually used in-game: 0 will disable the element entirely.</i>
  Enabled = <b>1</b>; 
  
  <i>// How much moving air or wind affects it.</i>
  Advection = <b>0.4f</b>; 
  <i>// How much air the particle "drags" along with it when moving. </i>
  AirDrag = <b>0.04f</b> * CFDS;
  <i>// How much the particle slows down moving air. 1 for no effect, 0 for full effect.</i> 
  AirLoss = <b>0.94f</b>; 
  <i>// How much speed the particle loses every frame. 1 = no loss. 0.5 = half loss.</i>
  Loss = <b>0.95f</b>; 
  <i>// When this particle hits something, this value somehow helps determine new velocity.
  // Ctrl+F .Collision in Simulation.cpp</i>
  Collision = <b>-0.1f</b>; 
  <i>// How fast the particle falls. Negative means it floats. </i>
  Gravity = <b>0.3f</b>; 
  <i>// How much the particle wiggles like GAS.</i>
  Diffusion = <b>0.00f</b>;
  <i>// How much the particle increases pressure. </i>
  HotAir = <b>0.000f</b>  * CFDS; 
  <i>// How does this particle move?
  // (0 = solid. 1 = powder. 2 = liquid) </i>
  Falldown = <b>1</b>; 
  
  <i>// How much this particle burns. 
  // (0 = not at all. &gt;0 = burns more.) </i>
  Flammable = <b>0</b>; 
  <i>// Does the particle explode? 
  // (0 = no. 1 = only with fire. 2 = with pressure &gt; 2.5 or with fire.)</i>
  Explosive = <b>0</b>; 
  <i>// Does it melt? 
  // (0 = no. 1 = yes)</i>
  Meltable = <b>5</b>; 
  <i>// How much acid affects the particle. 
  // (0 = not at all. &gt;0 = more corrodable)</i>
  Hardness = <b>2</b>; 

  <i>// Particle weight. Determines which sinks below which. 
  //(1 = gas. 2 = light. 0-49 = liquids. 50-99 = powders. 100 = solids. -1 for energy.)
  // Values aren't limited to that however.</i>
  Weight = <b>90</b>; 
  
  <i>// How hot does it spawn with? Automatically converted to Celsius.
  //  #define R_TEMP 22 &lt;src/simulation/Elements.h&gt;</i>
  Temperature = <b>R_TEMP+0.0f</b> + 273.15f; 
  <i>// How well it transfers heat. 
  // (0 = badly. 255 = very very well) </i>
  HeatConduct = <b>150</b>; 
  <i>// Element description, or the little text you get when mousing over the element menu item.</i>
  Description = "<b>Broken Coal. Heavy particles. See COAL</b>"; 
  
  <i>// Which state the element is in. 
  // (ST_NONE = other. ST_SOLID = Solid. ST_LIQUID = Liquid. ST_GAS = Gas.)</i>
  State = ST_<b>SOLID</b>; 

  <i>// Element properties. Binary OR them together.
  //  See <a href="http://tpt.io/.213774">this forum post</a> for details.</i>
  Properties = <b>TYPE_PART</b>; 


  <i>
  /*
    So this next part is about transitions. 
    How this works is, you have to tell TPT about your upper and lower threshold
    and the elements it'll change to when the threshold is met.
    There's also a few predefined elements for when you don't want transitions: 
    unreachable levels of pressure and temperature which will never trigger a 
    transition as well as an element for No Type.

    IPL = Impossibly Low Pressure (That Never Will Be Reached)
    IPH = Impossibly High Pressure
    NT = No Type Whatsoever
    ITL = Impossibly Low Temperature
    ITH = Impossibly High Temperature
  */</i>

  <i>// if pressure is lower than this then change to LowPressureTransition</i>
  LowPressure = <b>IPL</b>;
  LowPressureTransition = <b>NT</b>;

  <i>// if pressure is higher than this then change to HighPressureTransition</i>
  HighPressure = <b>IPH</b>; 
  HighPressureTransition = <b>NT</b>;

  <i>// if temperature is higher than this then change to HighTemperatureTransition</i>
  LowTemperature = <b>ITL</b>;
  LowTemperatureTransition = <b>NT</b>;

  <i>// if temperature is lower than this then change to LowTemperatureTransition</i>
  HighTemperature = <b>ITH</b>;
  HighTemperatureTransition = <b>NT</b>;
  
  <i>// address of the update function, 99% of the time it's Element_YOURELEMENT::update</i>
  Update = &amp;Element_<b>BCOL</b>::update;

  <i>// address of the graphics function. 50% of the time you won't need it, 
  // and 50% of the time all the time you will have it as Element_YOURELEMENT::graphics</i>
  Graphics = &amp;Element_<b>BCOL</b>::graphics; 
}
<i>
/* 

  #define UPDATE_FUNC_ARGS Simulation* sim, int i, int x, int y, 
          int surround_space, int nt, Particle *parts, int pmap[YRES][XRES]

  #define UPDATE_FUNC_SUBCALL_ARGS sim, i, x, y, surround_space, nt, parts, pmap
  #define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
          int *pixel_mode, int* cola, int *colr, int *colg, 
          int *colb, int *firea, int *firer, int *fireg, int *fireb

  #define GRAPHICS_FUNC_SUBCALL_ARGS ren, cpart, nx, ny, pixel_mode, cola, colr, 
          colg, colb, firea, firer, fireg, fireb
  #define BOUNDS_CHECK true
*/

// Reactions and movement go here</i>

//#TPT-Directive ElementHeader Element_<b>BCOL</b> static int update(UPDATE_FUNC_ARGS)
int Element_<b>BCOL</b>::update(UPDATE_FUNC_ARGS)
 {
  <b class="code">//Example code
  int r, rx, ry, trade, temp;
  if (parts[i]&gt;=0) {
    sim->create_part(i, x, y, PT_FIRE);
    return 1;
  } else if (parts[i].life &lt; 100) {
    parts[i].life--;
    sim->create_part(-1, x+rand()%3-1, y+rand()%3-1, PT_FIRE);
  }

  for (rx=-2; rx&lt;3; rx++)
    for (ry=-2; ry&lt;3; ry++)
      if (x+rx>=0 &amp;&amp; y+ry>0 &amp;&amp; x+rx&lt;XRES &amp;&amp; y+ry&lt;YRES &amp;&amp; (rx || ry))
      {
        r = pmap[y+ry][x+rx];
        if (!r)
          continue;
        if (((r&amp;0xFF)==PT_FIRE || (r&amp;0xFF)==PT_PLSM) &amp;&amp; 1>(rand()%500))
        {
          if (parts[i].life>100) {
            parts[i].life = 99;
          }
        }
        if ((r&amp;0xFF)==PT_LAVA &amp;&amp; 1>(rand()%500))
        {
          if (parts[r>>8].ctype == PT_IRON) {
            parts[r>>8].ctype = PT_METL;
            sim->kill_part(i);
                                                return 1;
          }
        }
      }
  /*if(100-parts[i].life > parts[i].tmp2)
    parts[i].tmp2 = 100-parts[i].life;
  if(parts[i].tmp2 &lt; 0) parts[i].tmp2 = 0;
  for ( trade = 0; trade&lt;4; trade ++)
  {
    rx = rand()%5-2;
    ry = rand()%5-2;
    if (x+rx>=0 &amp;&amp; y+ry>0 &amp;&amp; x+rx&lt;XRES &amp;&amp; y+ry&lt;YRES &amp;&amp; (rx || ry))
    {
      r = pmap[y+ry][x+rx];
      if (!r)
        continue;
      if (((r&amp;0xFF)==PT_COAL || (r&amp;0xFF)==PT_BCOL)&amp;&amp;(parts[i].tmp2>parts[r>>8].tmp2)&amp;&amp;parts[i].tmp2>0)//diffusion
      {
        int temp = parts[i].tmp2 - parts[r>>8].tmp2;
        if(temp &lt; 10)
          continue;
        if (temp ==1)
        {
          parts[r>>8].tmp2 ++;
          parts[i].tmp2 --;
        }
        else if (temp>0)
        {
          parts[r>>8].tmp2 += temp/2;
          parts[i].tmp2 -= temp/2;
        }
      }
    }
  }*/
  if(parts[i].temp > parts[i].tmp2)
    parts[i].tmp2 = parts[i].temp;
  return 0;
  </b>
}

<i>// Shinies go here</i>

//#TPT-Directive ElementHeader Element_<b>BCOL</b> static int graphics(GRAPHICS_FUNC_ARGS)
int Element_<b>BCOL</b>::graphics(GRAPHICS_FUNC_ARGS)
{
<b class="code">
  // Example code
  *colr += (cpart->tmp2-295.15f)/3;
  
  if (*colr > 170)
    *colr = 170;
  if (*colr &lt; *colg)
    *colr = *colg;
    
  *colg = *colb = *colr;

  if((cpart->temp-295.15f) > 300.0f-200.0f)
  {
    float frequency = 3.1415/(2*300.0f-(300.0f-200.0f));
    int q = ((cpart->temp-295.15f)>300.0f)?300.0f-(300.0f-200.0f):(cpart->temp-295.15f)-(300.0f-200.0f);

    *colr += sin(frequency*q) * 226;
    *colg += sin(frequency*q*4.55 +3.14) * 34;
    *colb += sin(frequency*q*2.22 +3.14) * 64;
  }
  return 0;
</b>
}

<i>// Explicit destructors!</i>
Element_<b>BCOL</b>::~Element_<b>BCOL</b>() {}

<i>
/* 
  If AND ONLY IF you can't use generator.py, 
  here are the lines to manually copy to ElementClasses.cpp and ElementClasses.h: 
  (Make sure to paste them into appropriate places - order probably matters for the
  elements.push_back line, but not for the ElementClasses.h lines!)
*/

// Into ElementClasses.h: 
</i>

#define PT_<b>BCOL</b> <b>73</b>

class Element_<b>BCOL</b> : public Element
{
public:
  Element_<b>BCOL</b>();
  virtual ~Element_<b>BCOL</b>();
  static int update(UPDATE_FUNC_ARGS);
};

<i>// Into ElementClasses.cpp (into the vector definition): </i>

elements.push_back(Element_<b>BCOL</b>());